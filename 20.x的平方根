**题目链接：**[69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

**题目描述：**

> 给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。
>
> 由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**
>
> **注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。
>
> 
>
> **示例 1：**
>
> ```
> 输入：x = 4
> 输出：2
> ```
>
> **示例 2：**
>
> ```
> 输入：x = 8
> 输出：2
> 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
> ```
>
> **提示：**
>
> - `0 <= x <= 231 - 1`

**解法一（暴力查找）：**

**算法思路：**

> 依次枚举`[0, x]` 之间的所有数 `i` ：
>
> 这里没有必要研究是否枚举到 `x / 2` 还是 `x / 2 + 1` 。因为我们找到结果之后直接就返回了，往后的情况就不会再判断。反而研究枚举区间，既耽误时间，又可能出错）
>
> ​		▪ 如果 `i * i == x` ，直接返回 x ；
>
> ​		▪ 如果 `i * i > x` ，说明之前的一个数是结果，返回 `i - 1` 。
>
> 由于 `i * i` 可能超过 `int` 的最大值，因此使用`long long` 类型

**算法代码：**

```cpp
class Solution {
public:
    int mySqrt(int x) {
        //由于两个较大的数相乘可能会超过 int 最大范围
        // 因此用long long
        long long i = 0;
        for(i = 0; i <= x; i++){
            // 如果两个数相乘正好等于 x，直接返回 i
            if(i * i == x) return i;
            // 如果第一次出现两个数相乘大于 x，说明结果是前一个数
            if(i * i > x) return i - 1;
        }
            // 为了处理oj题需要控制所有路径都有返回值
            return -1;
    }
};
```

**解法二（二分查找算法）：**

**算法思路：**

> 设 x 的平方根的最终结果为 index ：
>
> a. 分析 index 左右两次数据的特点：
>
> ​	▪ [0, index] 之间的元素，平方之后都是小于等于 x 的；
>
> ​	▪ [index + 1, x] 之间的元素，平方之后都是大于 x 的。
>
> 因此可以使用二分查找算法。
class Solution {
public:
    int mySqrt(int x) {
        if(x < 1) return 0;//处理边界情况
        int left = 1,right = x;
        while(left < right){
            long long mid = left + (right - left + 1) / 2; // 防溢出
                if(mid * mid <= x) left = mid;
                else right = mid - 1;
        }
        return left;
    }
};
